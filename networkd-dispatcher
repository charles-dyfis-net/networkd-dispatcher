#!/usr/bin/env python
# networkd-dispatcher
#   Dispatcher service for systemd-networkd, borrowed heavily from
#   networkd-notify.
# Copyright(c) 2016 by wave++ "Yuri D'Elia" <wavexx@thregr.org>
# Distributed under GPLv3+ (see COPYING) WITHOUT ANY WARRANTY.
# Copyright(c) 2017 by craftyguy "Clayton Craft" <clayton@craftyguy.net>
# Distributed under GPLv3+ (see COPYING) WITHOUT ANY WARRANTY.



from __future__ import print_function, division, generators, unicode_literals

import argparse
import collections
import json
import subprocess
import os
import stat
import logging

from gi.repository import GLib as glib

import dbus
import dbus.mainloop.glib

# FIXME: Why are we doing this?
def resolve_path(path_list):
    for path in path_list:
        if os.path.exists(path):
            return path
    return None

# Constants
NETWORKCTL_PATHS = ['/usr/bin/networkctl', '/bin/networkctl']
IWCONFIG_PATHS = ['/usr/bin/iwconfig', '/sbin/iwconfig']
NETWORKCTL = resolve_path(NETWORKCTL_PATHS)
IWCONFIG = resolve_path(IWCONFIG_PATHS)
DEFAULT_SCRIPT_DIR = '/etc/networkd-dispatcher'

STATE_IGN = {'carrier', 'degraded', None}
SINGLETONS = {'Type', 'ESSID', 'OperationalState'}

logger = logging.getLogger('networkd-dispatcher')


def unquote(buf, char='\\'):
    """Remove escape characters from iwconfig ESSID output"""
    idx = 0
    while True:
        idx = buf.find(char, idx)
        if idx < 0:
            break
        buf = buf[:idx] + buf[idx+1:]
        idx += 1
    return buf

NetworkctlListState = collections.namedtuple('NetworkctlListState', ['idx', 'link', 'type', 'operational', 'setup'])
def get_networkctl_list():
    """Update the mapping from interface index numbers to state"""
    out = subprocess.check_output([NETWORKCTL, 'list', '--no-pager', '--no-legend'])
    result = []
    for line in out.split(b'\n')[:-1]:
        fields = line.decode('ascii').split()
        result.append(NetworkctlListState(*fields))
    return result

def get_networkctl_status(iface_name):
    """Return a dictionary mapping keys to lists (or strings if in SINGLETONS)"""
    out = subprocess.check_output([NETWORKCTL, 'status', '--no-pager', '--no-legend', '--', iface_name])
    data = collections.defaultdict(list)
    oldk = None
    for line in out.split(b'\n')[1:-1]:
        line = line.decode('ascii')
        k = line[:16].strip() or oldk
        oldk = k
        v = line[18:].strip()
        if k in SINGLETONS:
            data[k] = v
        else:
            data[k].append(v)
    return data

def get_wlan_essid(iface_name):
    """Given an interface name, return its ESSID"""
    out = subprocess.check_output([IWCONFIG, '--', iface_name])
    line = out.split(b'\n')[0].decode('ascii')
    essid = line[line.find('ESSID:')+7:-3]
    return unquote(essid)

def scripts_in_path(path):
    """Given a directory name, return a sorted list of executables contained therein"""
    script_list = []
    if not os.path.exists(path):
        return []
    for filename in os.listdir(path):
        pathname = os.path.join(path, filename)
        if os.path.isfile(pathname):
            entry = os.stat(pathname)
            # Make sure script can be executed
            if not stat.S_IXUSR & entry.st_mode:
                print("Unable to execute script, check file mode: " + pathname)
            # Make sure script is owned by root
            elif entry.st_uid != 0 or entry.st_gid != 0:
                print("Unable to execute script, check file perms: " + pathname)
            else:
                script_list.append(pathname)
    return sorted(script_list)

AddressList = collections.namedtuple('AddressList', ['ipv4', 'ipv6'])
def parse_address_strings(addrs):
    """Given a list of addresses, discard uninteresting ones, and sort the rest into IPv4 vs IPv6"""
    ip4addrs = []
    ip6addrs = []
    for addr in addrs:
        if addr.startswith('127.') or \
           addr.startswith('fe80:'):
            continue
        if ':' in addr:
            ip6addrs.append(addr)
        elif '.' in addr:
            ip4addrs.append(addr)
    return AddressList(ip4addrs, ip6addrs)

class Dispatcher(object):
    def __init__(self, script_dir=DEFAULT_SCRIPT_DIR):
        self.iface_list = None
        self.ifaces_by_idx = None
        self.ifaces_by_name = None
        self.prior_states = {}
        self.script_dir = script_dir
        self._interface_scan()

    def __repr__(self):
        return '<Dispatcher(%r)>' % (self.__dict__,)

    def _interface_scan(self):
        self.iface_list = get_networkctl_list()
        self.ifaces_by_idx = dict([int(i.idx), i] for i in self.iface_list)
        self.ifaces_by_name = dict([i.link, i] for i in self.iface_list)
        logger.debug('Performed interface scan; state: %r', self)

    def register(self, bus=None):
        """Register this dispatcher to handle events from the given bus"""
        if bus is None:
            bus = dbus.SystemBus()
        bus.add_signal_receiver(self._receive_signal,
                                bus_name='org.freedesktop.network1',
                                signal_name='PropertiesChanged',
                                path_keyword='path')

    def trigger_all(self):
        """Immediately invoke all scripts for the last known (or initial) states for each interface"""
        logger.info('Triggering scripts for last-known state for all interfaces')
        for iface in self.iface_list:
            iface_name = iface.link
            state = self.prior_states.get(iface_name, iface.operational)
            self.handle_state(iface_name, state)

    def get_interface_data(self, iface_name, state):
        """Return JSON-serializable data representing all state needed to run hooks for the given interface"""
        data = {'Type': self.ifaces_by_name[iface_name].type, 'State': state}
        if state == 'routable':
            data.update(get_networkctl_status(iface_name))
        if data.get('Type') == 'wlan':
            data['ESSID'] = get_wlan_essid(iface_name)
        return data

    def get_scripts_list(self, state):
        """Return scripts for the given state"""
        return scripts_in_path(self.script_dir + "/" + state + ".d")

    def handle_state(self, iface_name, state):
        # Already handled this state? Do nothing.
        if self.prior_states.get(iface_name) == state:
            logger.debug('Ignoring notification for interface %r entering state %r: already known', iface_name, state)
            return
        self.prior_states[iface_name] = state

        if state in STATE_IGN:
            logger.debug('Ignored OperationalState %r seen, skipping', state)
            return

        # No actions to take? Do nothing.
        script_list = self.get_scripts_list(state)
        if script_list is None:
            logger.debug('Ignoring notification for interface %r entering state %r: no triggers', iface_name, state)
            return

        # Collect data
        data = self.get_interface_data(iface_name, state)
        (v4addrs, v6addrs) = parse_address_strings(data.get('Address', ()))

        # Set script env. variables
        script_env = dict(os.environ)
        script_env.update({
            'ADDR': (data.get('Address', ['']) + [''])[0],
            'ESSID': data.get('ESSID', ''),
            'IP_ADDRS': ' '.join(v4addrs),
            'IP6_ADDRS': ' '.join(v6addrs),
            'IFACE': iface_name,
            'STATE': str(state),
            'json': json.dumps(data),
        })

        # run all valid scripts in the list
        logger.debug('Running triggers for interface %r entering state %r with environment %r', iface_name, state, script_env)
        for script in script_list:
            ret = subprocess.Popen(script, env=script_env).wait()
            if ret != 0:
                logger.warning('Exit status %r from script %r invoked with environment %r', ret, script, script_env)

    def _receive_signal(self, typ, data, _, path):
        logger.debug('Signal: typ=%r, data=%r, path=%r', typ, data, path)
        if typ != 'org.freedesktop.network1.Link':
            logger.debug('Ignoring signal received with unexpected typ %r', typ)
            return
        if not path.startswith('/org/freedesktop/network1/link/_'):
            logger.warning('Ignoring signal received with unexpected path %r', path)
            return

        # Detect necessity of reloading map *before* filtering ignored states
        # http://thread.gmane.org/gmane.comp.sysutils.systemd.devel/36460
        idx = path[32:]
        idx = int(chr(int(idx[:2], 16)) + idx[2:])
        if idx not in self.ifaces_by_idx:
            # Try to reload configuration if even an ignored message is seen
            logger.warning('Unknown index %r seen, reloading interface list', idx)
            self._interface_scan()

        try:
            iface_name = self.ifaces_by_idx[idx].link
        except KeyError:
            # Presumptive race condition: We reloaded, but the index is still invalid
            logger.error('Unknown interface index %r seen even after reload', idx)
            return

        state = data.get('OperationalState', None)
        if state is not None:
            try:
                self.handle_state(iface_name, str(state))
            except Exception: # pylint: disable=broad-except
                logger.exception('Error handling notification for interface %r entering state %s', iface_name, state)


def main():
    ap = argparse.ArgumentParser(description='networkd dispatcher daemon')
    ap.add_argument('-S', '--script-dir', action='store', default=DEFAULT_SCRIPT_DIR,
        help='Location under which to look for scripts [default: %(default)s]')
    ap.add_argument('-T', '--run-startup-triggers', action='store_true',
        help='Generate events reflecting preexisting state and behavior on startup [default: %(default)s]')
    ap.add_argument('-v', '--verbose', action='count', default=0,
        help='Increment verbosity level once per call')
    ap.add_argument('-q', '--quiet', action='count', default=0,
        help='Decrement verbosity level once per call')
    args = ap.parse_args()

    verbosity_num = (args.verbose - args.quiet)
    if verbosity_num <= -2:
        log_level = logging.CRITICAL
    elif verbosity_num <= -1:
        log_level = logging.ERROR
    elif verbosity_num == 0:
        log_level = logging.WARNING
    elif verbosity_num == 1:
        log_level = logging.INFO
    else:
        log_level = logging.DEBUG
    logging.basicConfig(level=log_level)

    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

    dispatcher = Dispatcher(script_dir=args.script_dir)
    dispatcher.register()

    # After configuring the receiver, run initial operations
    if args.run_startup_triggers:
        dispatcher.trigger_all()

    # main loop
    mainloop = glib.MainLoop()
    mainloop.run()

if __name__ == '__main__':
    main()

# vim: ai et sts=4 sw=4 ts=4
