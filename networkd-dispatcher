#!/usr/bin/env python
# networkd-dispatcher
#   Dispatcher service for systemd-networkd, borrowed heavily from
#   networkd-notify.
# Copyright(c) 2016 by wave++ "Yuri D'Elia" <wavexx@thregr.org>
# Distributed under GPLv3+ (see COPYING) WITHOUT ANY WARRANTY.
# Copyright(c) 2017 by craftyguy "Clayton Craft" <clayton@craftyguy.net>
# Distributed under GPLv3+ (see COPYING) WITHOUT ANY WARRANTY.



from __future__ import print_function, division, generators, unicode_literals

import argparse
import collections
import errno
import json
import subprocess
import os
import signal
import socket
import stat
import sys

import gi
from gi.repository import GLib as glib

import dbus
import dbus.mainloop.glib


# Constants
NETWORKCTL = ['/usr/bin/networkctl', '/bin/networkctl']
IWCONFIG = ['/usr/bin/iwconfig', '/sbin/iwconfig']
APP_NAME  = 'networkd'

STATE_IGN = {'carrier', 'degraded'}
SINGLETONS = {'Type', 'ESSID', 'OperationalState'}

# Nifty globals
IFACE_MAP = {}
SCRIPT_DIR = '/etc/networkd-dispatcher'


def log(msg):
    """Print & flush msg to stdout.
    This solves printing to stdout with systemd's journal
    """
    print(msg)
    sys.stdout.flush()


def resolve_path(path_list):
    for path in path_list:
        if os.path.exists(path):
            return path
    return None


def update_iface_map():
    out = subprocess.check_output([NETWORKCTL, 'list', '--no-pager', '--no-legend'])
    IFACE_MAP.clear()
    for line in out.split(b'\n')[:-1]:
        fields = line.decode('ascii').split()
        IFACE_MAP[int(fields[0])] = fields[1]


def get_iface_data(iface):
    out = subprocess.check_output([NETWORKCTL, 'status', '--no-pager', '--no-legend', '--', iface])
    data = collections.defaultdict(list)
    oldk = None
    for line in out.split(b'\n')[1:-1]:
        line = line.decode('ascii')
        k = line[:16].strip() or oldk
        oldk = k
        v = line[18:].strip()
        if k in SINGLETONS:
            data[k] = v
        else:
            data[k].append(v)
    return data


def unquote(buf, char='\\'):
    idx = 0
    while True:
        idx = buf.find(char, idx)
        if idx < 0: break
        buf = buf[:idx] + buf[idx+1:]
        idx += 1
    return buf


def get_wlan_essid(iface):
    out = subprocess.check_output([IWCONFIG, '--', iface])
    line = out.split(b'\n')[0].decode('ascii')
    essid = line[line.find('ESSID:')+7:-3]
    return unquote(essid)


def get_scripts_list(state):
    script_list = list()
    path = SCRIPT_DIR + "/" + state + ".d"
    for filename in os.listdir(path):
        pathname = os.path.join(path, filename)
        if os.path.isfile(pathname):
            entry = os.stat(pathname)
            # Make sure script can be executed
            if not stat.S_IXUSR & entry.st_mode:
                log("Unable to execute script, check file mode: " + pathname)
            # Make sure script is owned by root
            elif entry.st_uid != 0 or entry.st_gid != 0:
                log("Unable to execute script, check file perms: " + pathname)
            else:
                script_list.append(pathname)
    return sorted(script_list)


def property_changed(typ, data, _, path):
    if typ != 'org.freedesktop.network1.Link':
        return
    if not path.startswith('/org/freedesktop/network1/link/_'):
        return
    if 'OperationalState' not in data:
        return
    state = data['OperationalState']
    if state in STATE_IGN:
        return

    # http://thread.gmane.org/gmane.comp.sysutils.systemd.devel/36460
    idx = path[32:]
    idx = int(chr(int(idx[:2], 16)) + idx[2:])
    try:
        iface = IFACE_MAP[idx]
    except:
        # Received an index for an interface that no longer exists, so ignore it
        return

    if state == 'routable':
        data = get_iface_data(iface)

        # fetch ESSID
        if data['Type'] == 'wlan':
            data['ESSID'] = get_wlan_essid(iface)

        # filter out uninteresting addresses
        addrs = []
        for addr in data.get('Address', ()):
            if addr.startswith('127.') or \
               addr.startswith('fe80:'):
                continue
            addrs.append(addr)
    script_list = get_scripts_list(state)
    if script_list is None:
        return

    # Set script env. variables
    script_env = dict(os.environ)
    script_env.update({
        'IFACE': iface,
        'STATE': str(state),
        'json': json.dumps(data),
    })
    if 'ESSID' in data:
        script_env['ESSID'] = data['ESSID']
    if 'Address' in data:
        # Construct space-delimited strings of ipv4 and ipv6 addresses
        ipaddrs = ''
        ip6addrs = ''
        for addr in data['Address']:
            # If there's a colon, it's got to be ipv6, right?
            if ':' in addr:
                ip6addrs += ' ' + addr + ' '
            # And a dot must indicate ipv4, right??
            elif '.' in addr:
                ipaddrs += ' ' + addr + ' '
        script_env['ADDR'] = data['Address'][0]
        script_env['IP_ADDRS'] = ipaddrs
        script_env['IP6_ADDRS'] = ip6addrs

    # run all valid scripts in the list
    #TODO: At some point, check return code and handle errors
    for script in script_list:
        ret = subprocess.Popen(script, env=script_env).wait()


def sd_notify(state, unset_environment=False):
    """Systemd sd_notify implementation for Python.
    Note: 'state' argument should be a dictionary.
    """
    if not state:
        log("sd_notify called with no state specified!")
        return -errno.EINVAL
    sock = None
    try:
        # Turn state, a dictionary, into a properly formatted string where
        # each 'key=val' combo in the dictionary is separated by a \n
        state_str = '\n'.join(['{0}={1}'.format(key,val) for (key,val) in state.items()])
        env = os.environ.get('NOTIFY_SOCKET', None)
        if not env:
            # Process was not invoked with systemd
            return -errno.EINVAL
        if env[0] not in ('/', '@'):
            log("Unable to determine NOTIFY_SOCKET")
            return -errno.EINVAL
        if env[0] == '@':
            env = '\0' + env[1:]
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
        if sock.sendto(bytearray(state_str, 'utf-8'), env) > 0:
            return 1
    except Exception as e:
        log(e)

    if sock:
        sock.close()
    if unset_environment:
        if 'NOTIFY_SOCKET' in os.environ:
            del os.environ['NOTIFY_SOCKET']

    return 0


if __name__ == '__main__':
    ap = argparse.ArgumentParser(description='networkd dispatcher daemon')
    args = ap.parse_args()

    NETWORKCTL = resolve_path(NETWORKCTL)
    IWCONFIG = resolve_path(IWCONFIG)

    # interfaces never change at runtime, right??
    update_iface_map()
    # listen on for networkd events
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
    bus = dbus.SystemBus()
    bus.add_signal_receiver(property_changed,
                            bus_name='org.freedesktop.network1',
                            signal_name='PropertiesChanged',
                            path_keyword='path')

    # main loop
    mainloop = glib.MainLoop()
    # Signal to systemd that service is runnning
    sd_notify(dict([('READY', 1)]))
    mainloop.run()

